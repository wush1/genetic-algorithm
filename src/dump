extern crate nalgebra as na;

use na::{DMatrix, Complex};

type Row<T> =  Vec<T>;
type Matrix<T> = Vec<Row<T>>;

struct NeuralNetwork {
    input_layer_size: usize,
    hidden_layer_size: usize,
    output_layer_size: usize,

    weights1: DMatrix<f32>,
    weights2: DMatrix<f32>,
}

impl NeuralNetwork {
    fn forward(&self, x: DMatrix<f32>) {
        let z2 = &self.weights1 * x;
        //self.sigmoid(self.weights1);

    }
    fn sigmoid(&self, z: DMatrix<f32>){
        for i in z.iter() {
            println!("{}", i)
        }
    }
}

fn new_network
(input_layer_size: usize, hidden_layer_size: usize, output_layer_size: usize) -> NeuralNetwork {
    NeuralNetwork {
        input_layer_size: input_layer_size,
        hidden_layer_size: hidden_layer_size,
        output_layer_size: output_layer_size,

        weights1: DMatrix::new_random(input_layer_size, hidden_layer_size),
        weights2: DMatrix::new_random(hidden_layer_size, output_layer_size),
    }
}

fn main() {
    let dm1 = DMatrix::from_row_slice(
        3,
        4,
        &[1.0, 0.0, 0.0,
          0.0, 1.0, 0.0,
          0.0, 0.0, 1.0,
          0.0, 0.0, 0.0],
    );
    let dm2 = DMatrix::from_row_slice(
        4,
        3,
        &[0.0, 0.0, 0.0, 0.0,
          1.0, 0.0, 0.0, 0.0,
          1.0, 0.0, 0.0, 0.0],
    );

    let dm3 = dm1 * dm2;

    let g: f32 = 10.0;
    let f = g.exp();
    println!("{}", f);
}
